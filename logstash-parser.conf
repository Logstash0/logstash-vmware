# logstash-parser.conf
# See README.rb for details.

# Input from Redis
input {
  redis {
    host => "172.24.69.125"
    port => "6379"
    data_type => "list"
    key => "logstash"
    codec => "json"
    type => "syslog"
  }
}

filter {
  if "esx" in [tags] {
    grok {
      break_on_match => false
      match => [
        "message", "<%{POSINT:syslog_pri}>%{TIMESTAMP_ISO8601:time} %{SYSLOGHOST:hostname} %{SYSLOGPROG}: (?<messagebody>(?<esx_system_info>(?:\[%{DATA:esx_thread_id} %{DATA:esx_loglevel} \'%{DATA:esx_service}\'\ ?%{DATA:esx_opID}])) \[%{DATA:esx_service_info}]\ (?<esx_message>(%{GREEDYDATA})))",
        "message", "<%{POSINT:syslog_pri}>%{TIMESTAMP_ISO8601:time} %{SYSLOGHOST:hostname} %{SYSLOGPROG}: (?<messagebody>(?<esx_system_info>(?:\[%{DATA:esx_thread_id} %{DATA:esx_loglevel} \'%{DATA:esx_service}\'\ ?%{DATA:esx_opID}])) (?<esx_message>(%{GREEDYDATA})))",
        "message", "<%{POSINT:syslog_pri}>%{TIMESTAMP_ISO8601:time} %{SYSLOGHOST:hostname} %{SYSLOGPROG}: %{GREEDYDATA:esx_message}"
      ]
    }
  }
  if "vcenter" in [tags] {
    grok {
      break_on_match => false
      match => [
        "message", "%{TIMESTAMP_ISO8601:time} (?<messagebody>(?<vce_system_info>(?:\[%{DATA:vce_thread_id} %{DATA:vce_loglevel} \'%{DATA:vce_service}\'\ ?%{DATA:vce_opID}])) \[%{DATA:vce_service_info}]\ (?<vce_message>(%{GREEDYDATA})))",
        "message", "%{TIMESTAMP_ISO8601:time} (?<messagebody>(?<vce_system_info>(?:\[%{DATA:vce_thread_id} %{DATA:vce_loglevel} \'%{DATA:vce_service}\'\ ?%{DATA:vce_opID}])) (?<vce_message>(%{GREEDYDATA})))",
        "message", "<%{POSINT:syslog_pri}>%{TIMESTAMP_ISO8601:time} %{GREEDYDATA:vce_message}"
      ]
    }
  }
  if "_grokparsefailure" in [tags] {
    grok {
      break_on_match => false
      match => [
        "message", "<%{POSINT:syslog_pri}>%{DATA:esxi_system_info},  (?<messagebody>(%{SYSLOGHOST:esx_hostname} %{SYSLOGPROG}: %{GREEDYDATA:esx_message}))",
        "message", "${GREEDYDATA:_parsing_failure}"
      ]
    }
    mutate {
      remove_tag => [ "_grokparsefailure" ]
    }
  }
  syslog_pri { }
  mutate {
    rename => [ "host", "ip_address" ]
    rename => [ "message", "message-raw" ]
    rename => [ "messagebody", "message" ]
    remove_field => [ "@version", "type" ]
  }
  cidr {
    add_tag => [ "np" ]
    address => [ "%{ip_address}" ]
    network => [ "172.24.0.0/16" ]
  }
}

output {
  elasticsearch_http {
    host => "172.24.69.124"
    port => "9200"
    flush_size => "1000"
    idle_flush_time => "30"
  }
#  stdout { codec => rubydebug }
}
